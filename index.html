<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>AR –î–∑–µ—Ä–∫–∞–ª–æ ‚Äî –ø—Ä–∏–∫—Ä—ñ–ø–ª–µ–Ω–Ω—è –¥–æ —Å—Ç—ñ–Ω–∏ (WebXR)</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
      }
      #overlayUI {
        position: fixed;
        inset: 0;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom) 12px;
      }
      .topbar,
      .bottombar {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .topbar {
        justify-content: space-between;
      }
      .bottombar {
        justify-content: center;
        margin-bottom: 8px;
      }
      .card {
        pointer-events: auto;
        background: rgba(22, 22, 22, 0.6);
        backdrop-filter: blur(8px);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 10px 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      .btn {
        pointer-events: auto;
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 10px 14px;
        background: rgba(255, 255, 255, 0.08);
        color: #fff;
        font: 500 14px/1 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial;
      }
      .btn:hover {
        background: rgba(255, 255, 255, 0.14);
      }
      .hint {
        font-size: 13px;
        opacity: 0.85;
      }

      /* Reticle (—Ç–æ—á–∫–∞ –ø—Ä–∏–ª–∏–ø–∞–Ω–Ω—è) */
      .crosshair {
        position: fixed;
        left: 50%;
        top: 50%;
        width: 20px;
        height: 20px;
        margin: -10px 0 0 -10px;
        pointer-events: none;
      }
      .crosshair::before,
      .crosshair::after {
        content: "";
        position: absolute;
        left: 50%;
        top: 50%;
        background: #fff;
      }
      .crosshair::before {
        width: 16px;
        height: 2px;
        transform: translate(-50%, -50%);
        opacity: 0.75;
      }
      .crosshair::after {
        width: 2px;
        height: 16px;
        transform: translate(-50%, -50%);
        opacity: 0.75;
      }

      #enterAR {
        position: fixed;
        left: 50%;
        bottom: 28px;
        transform: translateX(-50%);
        z-index: 10;
      }

      /* Helper for unsupported */
      #unsupported {
        position: fixed;
        inset: 0;
        display: none;
        place-items: center;
        background: #0b0b0b;
        color: #fff;
        padding: 20px;
        text-align: center;
      }
      #unsupported.show {
        display: grid;
      }
    </style>
  </head>
  <body>
    <!-- DOM Overlay for WebXR -->
    <div id="overlayUI" class="overlay" hidden>
      <div class="topbar">
        <div class="card hint">
          –ù–∞–≤–µ–¥—ñ—Ç—å –∫–∞–º–µ—Ä—É –Ω–∞ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É –ø–æ–≤–µ—Ä—Ö–Ω—é —Ç–∞ —Ç–æ—Ä–∫–Ω—ñ—Ç—å—Å—è, —â–æ–± –ø—Ä–∏–∫–ª–µ—ó—Ç–∏
          –¥–∑–µ—Ä–∫–∞–ª–æ. –©–∏–ø–æ–∫ ‚Äî –º–∞—Å—à—Ç–∞–±, –¥–≤–∞ –ø–∞–ª—å—Ü—ñ ‚Äî –æ–±–µ—Ä—Ç–∞–Ω–Ω—è.
        </div>
        <div class="card" style="display: flex; gap: 8px; align-items: center">
          <button id="resetBtn" class="btn" title="–°–∫–∏–Ω—É—Ç–∏ –¥–∑–µ—Ä–∫–∞–ª–æ">
            –°–∫–∏–Ω—É—Ç–∏
          </button>
          <button
            id="lockBtn"
            class="btn"
            title="–ó–∞—Ñ—ñ–∫—Å—É–≤–∞—Ç–∏/—Ä–æ–∑–±–ª–æ–∫—É–≤–∞—Ç–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó"
          >
            üîí –ë–ª–æ–∫
          </button>
        </div>
      </div>
      <div class="bottombar">
        <div class="card hint">
          –ü–æ—Ä–∞–¥–∞: —Ä—É—Ö–∞–π—Ç–µ—Å—è –ø–æ–≤—ñ–ª—å–Ω–æ, —â–æ–± —Å–∏—Å—Ç–µ–º–∞ –∫—Ä–∞—â–µ —Ä–æ–∑–ø—ñ–∑–Ω–∞–ª–∞ —Å—Ç—ñ–Ω—É.
        </div>
      </div>
    </div>

    <button id="enterAR" class="btn">–ó–∞–ø—É—Å—Ç–∏—Ç–∏ AR</button>
    <div id="unsupported" class="card">
      <div>
        <h2>–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î WebXR AR</h2>
        <p>
          –°–ø—Ä–æ–±—É–π—Ç–µ Chrome/Edge –Ω–∞ Android –∑ —É–≤—ñ–º–∫–Ω–µ–Ω–∏–º WebXR –∞–±–æ iOS Safari 17+
          –∑ WebXR Viewer. –°–∞–π—Ç –º–∞—î –±—É—Ç–∏ –Ω–∞ HTTPS.
        </p>
      </div>
    </div>
    <div class="crosshair" aria-hidden="true"></div>

    <script type="module">
      // --- –Ü–º–ø–æ—Ä—Ç–∏ Three.js (ESM –∑ CDN) ---
      import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
      import { XRControllerModelFactory } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/XRControllerModelFactory.js";

      // –ì–ª–æ–±–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ
      let renderer,
        scene,
        camera,
        xrSession,
        refSpace,
        viewerSpace,
        hitTestSource;
      let mirrorGroup = null; // –ì—Ä—É–ø–∞ –¥–∑–µ—Ä–∫–∞–ª–∞ (—Ä–∞–º–∫–∞ + –ø–æ–ª–æ—Ç–Ω–æ)
      let anchor = null; // –Ø–∫—ñ—Ä AR (–∑–∞ –Ω–∞—è–≤–Ω–æ—Å—Ç—ñ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏)
      let canTransform = true; // –ß–∏ –¥–æ–∑–≤–æ–ª–µ–Ω–æ –∂–µ—Å—Ç–∏

      const overlayRoot = document.getElementById("overlayUI");
      const enterBtn = document.getElementById("enterAR");
      const unsupported = document.getElementById("unsupported");
      const resetBtn = document.getElementById("resetBtn");
      const lockBtn = document.getElementById("lockBtn");

      // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ WebXR
      async function supportsAR() {
        if (!("xr" in navigator)) return false;
        try {
          return await navigator.xr.isSessionSupported("immersive-ar");
        } catch {
          return false;
        }
      }

      // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Å—Ü–µ–Ω–∏
      function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera();

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          powerPreference: "high-performance",
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // –ú'—è–∫–µ –æ—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è –¥–ª—è –∫—Ä–∞—â–æ—ó —è–∫–æ—Å—Ç—ñ —Ä–∞–º–∫–∏
        const ambient = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 0.4);
        dir.position.set(0.5, 1, 0.2);
        scene.add(dir);
      }

      // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è "–¥–∑–µ—Ä–∫–∞–ª–∞": —Ç–æ–Ω–∫–∞ –ø–ª–æ—â–∏–Ω–∞ + –µ–ª–µ–≥–∞–Ω—Ç–Ω–∞ —Ä–∞–º–∫–∞
      function createMirrorMesh(width = 0.6, height = 1.0, depth = 0.02) {
        const group = new THREE.Group();

        // –ü–æ–ª–æ—Ç–Ω–æ (—Å–∫–ª–æ): –Ω–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–∏–π, –∑ –ª–µ–≥–∫–∏–º –≤—ñ–¥–±–ª–∏—Å–∫–æ–º
        const glassGeo = new THREE.PlaneGeometry(width, height);
        const glassMat = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          metalness: 0.0,
          roughness: 0.05,
          transmission: 0.85, // —Å–∫–ª—è–Ω—ñ—Å—Ç—å
          thickness: 0.02,
          transparent: true,
          opacity: 0.95,
          clearcoat: 1.0,
          clearcoatRoughness: 0.05,
        });
        const glass = new THREE.Mesh(glassGeo, glassMat);
        glass.renderOrder = 1;

        // –†–∞–º–∫–∞ (–≤–∏—Ç–æ–Ω—á–µ–Ω–∞ –∞–ª—é–º—ñ–Ω—ñ—î–≤–∞)
        const frameThickness = 0.02;
        const frameDepth = depth;
        const outer = new THREE.BoxGeometry(
          width + frameThickness * 2,
          height + frameThickness * 2,
          frameDepth
        );
        const inner = new THREE.BoxGeometry(width, height, frameDepth + 0.001);
        // –ü–æ–±—É–¥–æ–≤–∞ —Ä–∞–º–∫–∏ —è–∫ —Ä—ñ–∑–Ω–∏—Ü—è ‚Äî —á–µ—Ä–µ–∑ Stencil –Ω–µ –ø—ñ–¥–µ–º–æ, –∑—Ä–æ–±–∏–º–æ 4 —Ä–µ–π–∫–∏
        const railMat = new THREE.MeshStandardMaterial({
          color: 0xbfc7d5,
          metalness: 0.8,
          roughness: 0.2,
        });
        const rails = new THREE.Group();
        const railW = frameThickness,
          railH = height + frameThickness * 2,
          railL = width + frameThickness * 2;
        const railGeoV = new THREE.BoxGeometry(railW, railH, frameDepth);
        const railGeoH = new THREE.BoxGeometry(railL, railW, frameDepth);
        const left = new THREE.Mesh(railGeoV, railMat);
        left.position.set(-(width / 2 + frameThickness / 2), 0, 0);
        const right = left.clone();
        right.position.x *= -1;
        const top = new THREE.Mesh(railGeoH, railMat);
        top.position.set(0, height / 2 + frameThickness / 2, 0);
        const bottom = top.clone();
        bottom.position.y *= -1;
        rails.add(left, right, top, bottom);

        // –¢—ñ–Ω—å–æ–≤–∞ –ø—ñ–¥–∫–ª–∞–¥–∫–∞ (–¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç—É –Ω–∞ —Å–≤—ñ—Ç–ª–∏—Ö —Å—Ç—ñ–Ω–∞—Ö)
        const shadowBack = new THREE.Mesh(
          new THREE.PlaneGeometry(
            width + frameThickness * 2.2,
            height + frameThickness * 2.2
          ),
          new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.08,
          })
        );
        shadowBack.position.z = -0.005;

        group.add(shadowBack, rails, glass);
        group.userData = { width, height };
        return group;
      }

      // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è AR-—Å–µ—Å—ñ—ó
      async function startAR() {
        if (!renderer) initThree();

        // –ó–∞–ø–∏—Ç AR-—Å–µ—Å—ñ—ó –∑ –ø–æ—Ç—Ä—ñ–±–Ω–∏–º–∏ —Ñ—ñ—á–∞–º–∏
        xrSession = await navigator.xr.requestSession("immersive-ar", {
          requiredFeatures: ["hit-test", "dom-overlay"],
          optionalFeatures: ["anchors", "plane-detection"],
          domOverlay: { root: document.body },
        });

        renderer.xr.setReferenceSpaceType("local");
        await renderer.xr.setSession(xrSession);

        refSpace = await xrSession.requestReferenceSpace("local");
        viewerSpace = await xrSession.requestReferenceSpace("viewer");

        // –î–∂–µ—Ä–µ–ª–æ hit-test (–≤—ñ–¥ –≥–ª—è–¥–∞—á–∞)
        hitTestSource = await xrSession.requestHitTestSource({
          space: viewerSpace,
        });

        // –ü–æ–∫–∞–∑–∞—Ç–∏ UI –ø–æ–≤–µ—Ä—Ö AR
        overlayRoot.hidden = false;
        enterBtn.style.display = "none";

        // –ö–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∏ –¥–ª—è –æ–±—Ä–æ–±–∫–∏ —Ç–∞–ø–∞
        const controller = renderer.xr.getController(0);
        controller.addEventListener("select", onSelectPlaceOrAnchor);
        scene.add(controller);

        // –ñ–µ—Å—Ç–∏ –º–∞—Å—à—Ç–∞–±/–æ–±–µ—Ä—Ç–∞–Ω–Ω—è —á–µ—Ä–µ–∑ touch-–ø–æ–¥—ñ—ó DOM overlay
        initGestureControls();

        // –ê–Ω—ñ–º–∞—Ü—ñ–π–Ω–∏–π —Ü–∏–∫–ª
        renderer.setAnimationLoop(onXRFrame);

        // –°—Ç–≤–æ—Ä—é—î–º–æ –¥–∑–µ—Ä–∫–∞–ª–æ –∑–∞–∑–¥–∞–ª–µ–≥—ñ–¥—å (–±—É–¥–µ –ø–µ—Ä–µ–º—ñ—â—É–≤–∞—Ç–∏—Å—è –∑–∞ reticle –¥–æ –º–æ–º–µ–Ω—Ç—É –ø—Ä–∏–∫–ª–µ—é–≤–∞–Ω–Ω—è)
        mirrorGroup = createMirrorMesh();
        mirrorGroup.visible = false; // —Å—Ç–∞–Ω–µ –≤–∏–¥–∏–º–∏–º, –∫–æ–ª–∏ –∑–Ω–∞–π–¥–µ–º–æ –ø–ª–æ—â–∏–Ω—É
        scene.add(mirrorGroup);
      }

      // –û–±—Ä–æ–±–∫–∞ –∫–æ–∂–Ω–æ–≥–æ XR –∫–∞–¥—Ä—É
      function onXRFrame(t, frame) {
        const session = frame.session;
        const pose = frame.getViewerPose(refSpace);
        if (!pose) return;

        // Hit test ‚Äî –∑–Ω–∞—Ö–æ–¥–∏–º–æ –ø–ª–æ—â–∏–Ω—É (—É —Ç.—á. –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É —Å—Ç—ñ–Ω—É)
        const results = frame.getHitTestResults(hitTestSource);
        if (results.length > 0) {
          const hit = results[0];
          const hitPose = hit.getPose(refSpace);

          // –û—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—è –ø–ª–æ—â–∏–Ω–∏: –ø—Ä–∞–≥–Ω–µ–º–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—ñ (—Å—Ç—ñ–Ω—ñ)
          // –î–ª—è –≤—ñ–∑—É–∞–ª—å–Ω–æ—ó —Å—Ç–∞–±—ñ–ª—å–Ω–æ—Å—Ç—ñ —Ç—Ä–æ—Ö–∏ –∑–≥–ª–∞–¥–∏–º–æ —Ä—É—Ö
          if (mirrorGroup && anchor === null) {
            mirrorGroup.visible = true;
            // –ü–æ–∑–∏—Ü—ñ—è –ø–µ—Ä–µ–¥ –∫–∞–º–µ—Ä–æ—é (–∑ hit-test)
            mirrorGroup.position.set(
              hitPose.transform.position.x,
              hitPose.transform.position.y,
              hitPose.transform.position.z
            );

            // –û—Ä—ñ—î–Ω—Ç—É—î–º–æ –ø–ª–æ—â–∏–Ω—É, —â–æ–± –≤–æ–Ω–∞ –¥–∏–≤–∏–ª–∞—Å—è –Ω–∞ –∫–∞–º–µ—Ä—É (—Ç–æ–±—Ç–æ —Å—Ç–∞–ª–∞ –ø–∞—Ä–∞–ª–µ–ª—å–Ω–æ —Å—Ç—ñ–Ω—ñ)
            const q = hitPose.transform.orientation;
            mirrorGroup.quaternion.set(q.x, q.y, q.z, q.w);
          }
        }

        renderer.render(scene, camera);
      }

      // –ü–æ —Ç–∞–ø—É: –∞–±–æ –∑–∞–∫—Ä—ñ–ø–ª—é—î–º–æ (anchor), –∞–±–æ –ø–µ—Ä–µ–º–∏–∫–∞—î–º–æ –ø–æ–ª–æ–∂–µ–Ω–Ω—è
      async function onSelectPlaceOrAnchor(event) {
        if (!mirrorGroup) return;

        const xrFrame = renderer.xr.getFrame();
        if (!xrFrame) return;

        const results = xrFrame.getHitTestResults(hitTestSource);
        if (results.length === 0) return;

        const hit = results[0];
        const pose = hit.getPose(refSpace);

        // –Ø–∫—â–æ –ø—ñ–¥—Ç—Ä–∏–º—É—é—Ç—å—Å—è —è–∫–æ—Ä—ñ ‚Äî –ø—Ä–∏–≤'—è–∑—É—î–º–æ, —â–æ–± –¥–∑–µ—Ä–∫–∞–ª–æ "–ø—Ä–∏–ª–∏–ø–ª–æ" –¥–æ —Å—Ç—ñ–Ω–∏ —Å—Ç–∞–±—ñ–ª—å–Ω–æ
        try {
          if (xrFrame.createAnchor) {
            if (anchor) {
              anchor.delete();
              anchor = null;
            }
            anchor = await xrFrame.createAnchor(pose.transform, refSpace);
            anchor.addEventListener("remove", () => {
              anchor = null;
            });
            // –ü—Ä–∏–≤'—è–∑—É—î–º–æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—é –¥–∑–µ—Ä–∫–∞–ª–∞ –¥–æ —è–∫–æ—Ä—è
            const anchorSpace = anchor.anchorSpace;
            // –û–Ω–æ–≤–ª—é—î–º–æ –ø–æ–∑—É –¥–∑–µ—Ä–∫–∞–ª–∞ –∫–æ–∂–Ω–æ–≥–æ –∫–∞–¥—Ä—É —á–µ—Ä–µ–∑ anchorSpace
            const prevLoop = renderer.getAnimationLoop();
            renderer.setAnimationLoop((t, frame) => {
              const anchorPose = frame.getPose(anchorSpace, refSpace);
              if (anchorPose) {
                mirrorGroup.position.set(
                  anchorPose.transform.position.x,
                  anchorPose.transform.position.y,
                  anchorPose.transform.position.z
                );
                const o = anchorPose.transform.orientation;
                mirrorGroup.quaternion.set(o.x, o.y, o.z, o.w);
              }
              prevLoop && prevLoop(t, frame);
            });
          } else {
            // –§–æ–ª–±–µ–∫: –ø—Ä–æ—Å—Ç–æ —Ñ—ñ–∫—Å—É—î–º–æ –ø–æ—Ç–æ—á–Ω—É –ø–æ–∑—É –±–µ–∑ anchor
            mirrorGroup.position.set(
              pose.transform.position.x,
              pose.transform.position.y,
              pose.transform.position.z
            );
            const o = pose.transform.orientation;
            mirrorGroup.quaternion.set(o.x, o.y, o.z, o.w);
          }
        } catch (e) {
          console.warn("Anchor not available:", e);
        }
      }

      // –ñ–µ—Å—Ç–∏ –º–∞—Å—à—Ç–∞–±—É/–æ–±–µ—Ä—Ç–∞–Ω–Ω—è (2 –ø–∞–ª—å—Ü—ñ)
      function initGestureControls() {
        let prevDist = 0,
          prevAngle = 0;
        let active = false;

        function getTouches(e) {
          return [...e.touches]
            .slice(0, 2)
            .map((t) => ({ x: t.clientX, y: t.clientY }));
        }
        function dist(a, b) {
          const dx = a.x - b.x,
            dy = a.y - b.y;
          return Math.hypot(dx, dy);
        }
        function angle(a, b) {
          return Math.atan2(b.y - a.y, b.x - a.x);
        }

        window.addEventListener(
          "touchstart",
          (e) => {
            if (!mirrorGroup || !canTransform) return;
            if (e.touches.length === 2) {
              const [p1, p2] = getTouches(e);
              prevDist = dist(p1, p2);
              prevAngle = angle(p1, p2);
              active = true;
            }
          },
          { passive: true }
        );

        window.addEventListener(
          "touchmove",
          (e) => {
            if (!active || !mirrorGroup || !canTransform) return;
            if (e.touches.length === 2) {
              const [p1, p2] = getTouches(e);
              const d = dist(p1, p2);
              const a = angle(p1, p2);
              const scale = THREE.MathUtils.clamp(d / prevDist, 0.6, 1.6);
              mirrorGroup.scale.multiplyScalar(scale);
              // –û–±–µ—Ä—Ç–∞–Ω–Ω—è –Ω–∞–≤–∫–æ–ª–æ –Ω–æ—Ä–º–∞–ª—ñ (Y —Ç—É—Ç —è–∫ –ø—Ä–∏–±–ª–∏–∑–Ω–∞ –≤—ñ—Å—å)
              const deltaA = a - prevAngle;
              mirrorGroup.rotateY(deltaA);
              prevDist = d;
              prevAngle = a;
            }
          },
          { passive: true }
        );

        window.addEventListener(
          "touchend",
          () => {
            active = false;
          },
          { passive: true }
        );

        resetBtn.onclick = () => {
          if (!mirrorGroup) return;
          mirrorGroup.scale.set(1, 1, 1);
          if (anchor) {
            try {
              anchor.delete();
            } catch {}
            anchor = null;
          }
        };

        lockBtn.onclick = () => {
          canTransform = !canTransform;
          lockBtn.textContent = canTransform ? "üîí –ë–ª–æ–∫" : "üîì –†–µ–¥–∞–≥—É–≤–∞—Ç–∏";
        };
      }

      // –ö–Ω–æ–ø–∫–∞ –≤—Ö–æ–¥—É
      (async () => {
        const ok = await supportsAR();
        if (!ok) {
          unsupported.classList.add("show");
          enterBtn.style.display = "none";
          return;
        }
        enterBtn.addEventListener("click", startAR);
      })();

      // Resize
      window.addEventListener("resize", () => {
        if (renderer) {
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>
